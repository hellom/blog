{"dependencies":[],"generated":{"js":"var global = (1,eval)(\"this\");\n/*! callbacks.js - v1.0.4 - 2017-12-07\n* https://github.com/simplefeel/callbacks.js\n* Copyright (c) 2017 ; Licensed  */\n\n\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.callbacks = factory());\n}(this, (function () { 'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar optionsCache = {};\nfunction createOptions(options) {\n    var object = optionsCache[options] = {};\n    options.match(/\\S+/g).forEach(function (item, index) {\n        object[item] = true;\n    });\n    return object;\n}\n\nvar callbacks = function callbacks(options) {\n    options = typeof options === 'string' ? optionsCache[options] || createOptions(options) : Object.assign({}, options);\n    var memory,\n        fired,\n        firing,\n        firingStart,\n        firingLength,\n        firingIndex,\n        list = [],\n        stack = !options.once && [];\n\n    var fire = function fire(data) {\n        memory = options.memory && data;\n        fired = true;\n        firingIndex = firingStart || 0;\n        firingStart = 0;\n        firingLength = list.length;\n        firing = true;\n\n        for (; list && firingIndex < firingLength; firingIndex++) {\n            if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {\n                memory = false;\n                break;\n            }\n        }\n\n        firing = false;\n        if (list) {\n            if (stack) {\n                if (stack.length) {\n                    fire(stack.shift());\n                }\n            } else if (memory) {\n                console.log(memory);\n                list = [];\n            } else {\n                self.disable();\n            }\n        }\n    };\n\n    var inArray = function inArray(elem, arr, i) {\n        var len;\n        if (arr) {\n            if (arr.indexOf) {\n                return arr.indexOf(elem, i);\n            }\n\n            len = arr.length;\n            i = i ? i < 0 ? Math.max(0, len + i) : i : 0;\n            for (; i < len; i++) {\n                if (i in arr && arr[i] === elem) {\n                    return i;\n                }\n            }\n        }\n\n        return -1;\n    };\n\n    var self = {\n        add: function add() {\n            if (list) {\n                var start = list.length;\n                (function add(args) {\n                    [].forEach.call(args, function (arg, i) {\n                        var type = typeof arg === 'undefined' ? 'undefined' : _typeof(arg);\n                        if (type === 'function') {\n                            if (!options.unique || !self.has(arg)) {\n                                list.push(arg);\n                            }\n                        } else if (arg && arg.length && type !== 'string') {\n                            add(arg);\n                        }\n                    });\n                })(arguments);\n\n                if (firing) {\n                    firingLength = list.length;\n                } else if (memory) {\n                    firingStart = start;\n                    fire(memory);\n                }\n            }\n            return this;\n        },\n\n        fire: function fire() {\n            self.fireWith(this, arguments);\n            return this;\n        },\n\n        fireWith: function fireWith(context, args) {\n            if (list && (!fired || stack)) {\n                args = args || [];\n                args = [context, args.slice ? args.slice() : args];\n                if (firing) {\n                    stack.push(args);\n                } else {\n                    fire(args);\n                }\n            }\n            return this;\n        },\n\n        disable: function disable() {\n            list = stack = memory = undefined;\n            return this;\n        },\n\n        has: function has(fn) {\n            return fn ? inArray(fn, list) > -1 : !!(list && list.length);\n        },\n\n        remove: function remove() {\n            if (list) {\n                [].forEach.call(arguments, function (arg, i) {\n                    var index;\n                    while ((index = inArray(arg, list, index)) > -1) {\n                        list.splice(index, 1);\n                        if (firing) {\n                            if (index <= firingLength) {\n                                firingLength--;\n                            }\n                            if (index <= firingIndex) {\n                                firingIndex--;\n                            }\n                        }\n                    }\n                });\n            }\n            return this;\n        },\n\n        empty: function empty() {\n            list = [];\n            firingLength = 0;\n            return this;\n        }\n    };\n    return self;\n};\n\nreturn callbacks;\n\n})));\n"},"hash":"d06afd05b5dbf11b90365d4b345e8657"}